_=_ : Π {α : U}, α → α → U
idp : Π {α : U} (a : α), a = a
_⁻¹ : Π {α : U} {a b : α}, a = b → b = a
_⬝_ : Π {α : U} {a b c : α}, a = b → b = c → a = c

(p ⬝ q) ⬝ r   ~> p ⬝ (q ⬝ r)
(p ⬝ q)⁻¹     ~> q⁻¹ ⬝ p⁻¹
p ⬝ (p⁻¹ ⬝ q) ~> q
p⁻¹ ⬝ (p ⬝ q) ~> q
p ⬝ p⁻¹       ~> idp a
p⁻¹ ⬝ p       ~> idp b
(p⁻¹)⁻¹       ~> p
(idp x)⁻¹     ~> idp x
p ⬝ idp b     ~> p
idp a ⬝ p     ~> p

      ∂ : Π {α : U}, α → α → α → Prop
   left : Π {α : U} (a b : α), ∂ a b a
  right : Π {α : U} (a b : α), ∂ a b b
 ∂-symm : Π {α : U} {a b x : α}, ∂ a b x → ∂ b a x
 ∂-comp : Π {α : U} {a b x y : α}, ∂ a b x → ∂ x b y → ∂ a b y
 ∂-left : Π {α : U} {a b c x : α}, ∂ a b x → a = c → ∂ c b x
∂-right : Π {α : U} {a b c x : α}, ∂ a b x → b = c → ∂ a c x
 ∂-cong : Π {α β : U} {a b : α} (f : Π (x : α), ∂ a b x → β)
            (x : α) (H : ∂ a b x), ∂ (f a (left a b)) (f b (right a b)) (f x H)

Maybe these rules for ∂-symm and ∂-comp are not necessary
due to proof-irrelevance, but they should improve efficiency.

∂-symm  (left a b) ~> right b a
∂-symm (right a b) ~> left  b a
 ∂-symm (∂-symm H) ~> H

 ∂-cong f a (left a b) ~> left (f a (left a b)) (f b (right a b))
∂-cong f b (right a b) ~> right (f a (left a b)) (f b (right a b))

“∂-comp u v, ∂-left H p, ∂-right right : ∂ a b x” should evaluate to “left a b”
when a ≡ x and to “right a b” when b ≡ x.

singl {α : U} (a : α) := Σ (b : α), a = b

  coe : Π {α β : U} : α = β → α → β
cong′ : Π {α β : U} {a b : α} (f : Π (x : α), ∂ a b x → β), a = b → f a left = f b right
 meet : Π {α : U} {a b : α} (p : a = b) (x : α), ∂ a b x → singl a

cong f p := cong′ (λ x _, f x) p

M¹) meet p a left  ~> (a, idp a)
M²) meet p b right ~> (b, p)

There is clash between M¹ and M² when a ≡ b (e.g. for loop : base = base).
Probably, one of M¹, M² must take priority in this case, otherwise we will get K.

(meet p x H).1 ~> x

coe (p ⬝ q) x ~> coe q (coe p x)
coe (idp α) x ~> x

coe (cong (λ x, Π (a : α[x]), β[x] a) p) φ x ~>
  coe (cong′ (λ y H, β[x/(meet p⁻¹ y (∂-symm H)).1] (coe (cong (λ y′, α[x/y′]) (meet p⁻¹ y (∂-symm H)).2) x)) p)
    (φ (coe (cong (λ y, α[x/y]) p⁻¹) x))

coe (cong (λ x, Σ (a : α[x]), β[x] a) p) z ~>
  (coe (cong′ (λ y, α[x/y]) p) z.1,
   coe (cong′ (λ y H, β[x/(meet p y H).1] (coe (cong (λ y′, α[x/y′]) (meet p y H).2) z.1)) p) z.2)

apd (f : Π (x : α), β x) p := cong′ (λ y H, coe (cong β ((meet p⁻¹ y (∂-symm H)).2)⁻¹) (f (meet p⁻¹ y (∂-symm H)).1)) p
  : coe (cong β ((meet p⁻¹ a (∂-symm left)).2)⁻¹)  (f (meet p⁻¹ a (∂-symm left)).1) =
    coe (cong β ((meet p⁻¹ b (∂-symm right)).2)⁻¹) (f (meet p⁻¹ b (∂-symm right)).1)
 ~> coe (cong β (p⁻¹)⁻¹) (f a) = coe (cong β (idp b)⁻¹) (f b)
 ~>       coe (cong β p) (f a) = coe (cong β (idp b)) (f b)
 ~>       coe (cong β p) (f a) = coe (idp (β b)) (f b)
 ~>       coe (cong β p) (f a) = f b

coe (cong (λ x, f[x] = g[x]) p) q ~> (apd (λ y, f[x/y]) p)⁻¹ ⬝ cong (coe (cong β p)) q ⬝ apd (λ y, g[x/y]) p

Similar rules should be applied in cases like coe (cong (λ x, Π (a : α[x]), β[x] a) p)⁻¹ φ

       cong f p⁻¹ ~> (cong f p)⁻¹
   cong f (p ⬝ q) ~> cong f p ⬝ cong f q
cong g (cong f p) ~> cong (g ∘ f) p
        cong id p ~> p
  cong (λ _, x) p ~> idp x
   cong f (idp x) ~> idp (f x)

ua : α ≃ β → α = β

     (ua e)⁻¹ ~> ua e⁻¹
ua e₁ ⬝ ua e₂ ~> ua (e₂ ∘ e₁)
 ua (ideqv α) ~> idp α
 coe (ua e) x ~> e.1 x

    Z : U
 zero : Z
 succ : Z → Z
 pred : Z → Z
Z-ind : Π (β : Z → V), β zero → (Π z, β z → β (succ z)) → (Π z, β z → β (pred z)) → Π z, β z

succ (pred z) ~> z
pred (succ z) ~> z

    Z-ind β z s p zero ~> z
Z-ind β z s p (succ z) ~> s (Z-ind β z s p z)
Z-ind β z s p (pred z) ~> p (Z-ind β z s p z)

     S¹ : U
   base : S¹
   loop : Path S¹ base base
 S¹-ind : Π (β : S¹ → U) (b : β base), Path (β base) (coe (cong β loop) b) b → Π (x : S¹), β x
S¹-indˢ : Π (β : S¹ → V) (f g : Π (x : S¹), β x), Id (β base) (f base) (g base) → Π (x : S¹), Id A (f x) (g x)

                S¹-ind β b ℓ base ~> b
cong (λ x H, S¹-ind β b ℓ x) loop ~> ℓ[x/base, H/left base base] ⬝ cong (λ x′ H′, b[x/x′, H/H′]) loop
             S¹-indˢ β f g p base ~> p

     R : U
  elem : Z → R
  glue : Π (z : Z), Path R (elem z) (elem (succ z))
 R-ind : Π (β : R → U) (cz : Π z, β (elem z)), (Π z, Path (β (elem (succ z))) (coe (cong β (glue z)) (cz z)) (cz (succ z))) → Π z, β z
R-indˢ : Π (β : R → V) (f g : Π (z : R), β x), (Π (z : Z), Id (β (elem x)) (f (elem x)) (g (elem x))) → Π (x : R), Id (β x) (f x) (g x)
 R-inj : Π (x y : Z), Id R (elem x) (elem y) → Id Z x y

              R-ind β cz sz (elem z) ~> cz z
cong (λ x H, R-ind β cz sz) (glue z) ~> sz z
             R-indˢ β f g p (elem z) ~> p z
           R-inj x x (refl (elem x)) ~> refl x